import mathimport numpy as npimport pandas as pdfrom scipy import spatialclass NetworkFormationModel:        def __init__(        self,        n: int,        m: int,        k_cap_mean: float,        k_cap_sd: float,        epsilon: float = 0.1,    ) -> None:        """        """        # Hyperparameters        self.n = n        self.m = m        self.k_cap_mean = k_cap_mean        self.k_cap_sd = k_cap_sd        self.epsilon = epsilon                # Set individuals variables        self.individuals = pd.DataFrame({'id': np.arange(n)})        self.social_network = pd.DataFrame(0, index=range(n), columns=range(n))                # Calculate and set degree caps        k_sigma2 = np.log(1.0 + (k_cap_sd**2) / (k_cap_mean**2))        k_mu = np.log(k_cap_mean) - 0.5 * k_sigma2        self.k_limit = np.random.lognormal(mean=k_mu, sigma=k_sigma2)            def set_up_world(self, density: float):        """        Given desired density,        place individuals on boundariless grid.        """        # Calculate grid size        D = math.sqrt(self.n / density)                        # Place individual on (torus) grid        self.individuals['x'] = np.random.uniform(low=0, high=D, size=self.n)        self.individuals['y'] = np.random.uniform(low=0, high=D, size=self.n)                    def create_social_network(self):        """        """        # Calculate distances between all individuals        distance_matrix = spatial.distance_matrix(            self.individuals[['x', 'y']].values,            self.individuals[['x', 'y']].values,        )                # Loop through individuals, creating edges        edge_number = 0        round_number = 0        while edge_number < self.k and round_number < 5*self.k:            i = np.random.choice(np.arange(self.n))                        # Only consider connection formation if agent has capacity            if self.social_network.iloc[i, :].sum() < self.k_limit[i]:                d = distance_matrix[i, :]                k = self.social_network.sum(axis=0)                                # Remove i from consideration                d[i] = np.inf  # distance to self = inf                k[i] = 0  # capacity = 0                                # Weighting function                w = (k + self.epsilon) * (d**-2)                                # normalize probabilities                p = w / w.sum()                                # Draw partner                j = np.random.choice(np.arange(self.n), p=p)                                # Add social tie if possible                if (                        self.social_network[i, j] == 0 and                        self.social_network.iloc[j, :].sum < self.k_limit[j]                ):                    self.social_network[i, j] = 1                    self.social_network[j, i] = 1                    edge_number += 1                                        # Iterate count            round_number += 1